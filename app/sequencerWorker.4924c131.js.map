{"version":3,"sources":["interface.ts","Zic/sequencerWorker.ts"],"names":[],"mappings":";AAGA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,QAAA,UAAA,QAAA,wBAAA,EAHO,IAAM,EAAqB,EAGlC,QAAA,mBAAA,EAFO,IAEK,EAFC,EAAY,EAAI,EAE7B,QAAA,UAAA,EAAA,QAAA,aAAA,EAAA,SAAY,GACR,EAAA,EAAA,KAAA,GAAA,OACA,EAAA,EAAA,OAAA,GAAA,SAFJ,CAAY,IAAA,QAAA,aAAA,EAAY;;AC2DxB,aAlDA,IAZA,IAAA,EAAA,QAAA,gBA8DA,EAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,EAAA,SAAA,EAAA,GAAA,IAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,OAAA,UAAA,eAAA,KAAA,EAAA,IAAA,EAAA,QAAA,GAAA,IAAA,EAAA,GAAA,EAAA,IAAA,GAAA,MAAA,GAAA,mBAAA,OAAA,sBAAA,CAAA,IAAA,EAAA,EAAA,IAAA,EAAA,OAAA,sBAAA,GAAA,EAAA,EAAA,OAAA,IAAA,EAAA,QAAA,EAAA,IAAA,GAAA,OAAA,UAAA,qBAAA,KAAA,EAAA,EAAA,MAAA,EAAA,EAAA,IAAA,EAAA,EAAA,KAAA,OAAA,GAtDM,EAAK,GACP,EAAU,EACR,EAAkC,EAArB,EAAqB,mBAClC,EAAyB,GACtB,EAAI,EAAG,EAAI,EAAY,IAC5B,EAAK,GAAK,GAed,SAAS,EAAa,GACb,IAAA,IAAI,EAAU,EAAG,EAAU,EAAK,OAAQ,IAAW,CAC9C,IAAA,EAAQ,EAAK,GAAS,UAAU,SAAC,GAAW,OAAP,EAAA,KAAc,EAAK,KAC1D,IAAW,IAAX,EACO,MAAA,CAAE,QAAO,EAAE,MAAK,IAKnC,SAAS,EAAa,GAClB,EAAM,QAAQ,SAAC,GACL,IAAA,EAAM,EAAa,GACrB,GACI,EAAI,UAAY,EAAK,SACrB,EAAK,EAAI,SAAS,OAAO,EAAI,MAAO,GAExC,EAAK,EAAK,SAAS,EAAI,OAAS,GAEhC,EAAK,EAAK,SAAS,KAAK,KAKpC,SAAS,EAAgB,GACrB,EAAM,QAAQ,SAAC,GACL,IAAA,EAAM,EAAa,GACzB,GAAO,EAAK,EAAI,SAAS,OAAO,EAAI,MAAO,KAInD,SAAS,EAAK,GACT,KAAa,YAAY,GA3C9B,KAAK,iBACD,UACA,SAAC,GAAE,IAAA,EAAA,EAAA,KAAQ,EAAM,EAAA,OAAE,EAAK,EAAA,MAChB,IAAW,EAAa,aAAA,KACxB,EAAa,GACN,IAAW,EAAa,aAAA,QAC/B,EAAgB,KAGxB,GAqCJ,YAAY,WAER,EADA,GAAW,EAAU,GAAK,GACZ,QAAQ,SAAC,GAAE,IAAA,EAAE,EAAA,GAAE,EAAG,EAAA,IAAE,EAAQ,EAAA,SAAE,EAAK,EAAA,MAAK,EAAG,EAAA,EAAlC,CAAA,KAAA,MAAA,WAAA,UACnB,EAAI,EAAA,EAAA,GAAM,GAAG,CAAE,KAAM,EAAI,KAAM,QAC/B,WACI,WAAM,OAAA,EAAI,EAAA,EAAA,GAAM,GAAG,CAAE,KAAM,EAAK,KAAM,UACtC,GAAM,GAAY,EAAQ,EAAI,QAGvC","file":"sequencerWorker.4924c131.js","sourceRoot":"../src","sourcesContent":["export const MAX_STEPS_PER_BEAT = 8;\nexport const STEP_TICK = 1 / MAX_STEPS_PER_BEAT;\n\nexport enum ActionWorker {\n    save,\n    remove,\n}\n\nexport interface MsgWorker {\n    action: ActionWorker;\n    notes: NoteInWorker[];\n}\n\nexport interface NoteInWorker {\n    id: string;\n    outputId: string;\n    trigger: number;\n    duration: number;\n    slide?: boolean;\n    on: any;\n    off: any;\n}\n\n// NoteOutWorker?\nexport interface DataOutWorker {\n    id: string;\n    outputId: string;\n    type: 'on' | 'off';\n    data: any;\n}\n","import {\n    ActionWorker,\n    MAX_STEPS_PER_BEAT,\n    MsgWorker,\n    NoteInWorker,\n    DataOutWorker,\n} from '../interface';\n\nconst ms = 75;\nlet counter = 0;\nconst stepsCount = MAX_STEPS_PER_BEAT * 4;\nconst list: NoteInWorker[][] = [];\nfor (let n = 0; n < stepsCount; n++) {\n    list[n] = [];\n}\n\nself.addEventListener(\n    'message',\n    ({ data: { action, notes } }: { data: MsgWorker }) => {\n        if (action === ActionWorker.save) {\n            saveSequence(notes);\n        } else if (action === ActionWorker.remove) {\n            removeSequences(notes);\n        }\n    },\n    false,\n);\n\nfunction findSequence(note: NoteInWorker) {\n    for (let trigger = 0; trigger < list.length; trigger++) {\n        const index = list[trigger].findIndex(({ id }) => id === note.id);\n        if (index !== -1) {\n            return { trigger, index };\n        }\n    }\n}\n\nfunction saveSequence(notes: NoteInWorker[]) {\n    notes.forEach((note) => {\n        const pos = findSequence(note);\n        if (pos) {\n            if (pos.trigger !== note.trigger) {\n                list[pos.trigger].splice(pos.index, 1);\n            }\n            list[note.trigger][pos.index] = note;\n        } else {\n            list[note.trigger].push(note);\n        }\n    });\n}\n\nfunction removeSequences(notes: NoteInWorker[]) {\n    notes.forEach((note) => {\n        const pos = findSequence(note);\n        pos && list[pos.trigger].splice(pos.index, 1);\n    });\n}\n\nfunction post(msg: DataOutWorker) {\n    (self as any).postMessage(msg);\n}\n\nsetInterval(() => {\n    counter = (counter + 1) % stepsCount;\n    list[counter].forEach(({ on, off, duration, slide, ...msg }) => {\n        post({ ...msg, data: on, type: 'on' });\n        setTimeout(\n            () => post({ ...msg, data: off, type: 'off' }),\n            ms * (duration + (slide ? 5 : 0)),\n        );\n    });\n}, ms);\n"]}